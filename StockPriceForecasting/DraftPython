import random
from datetime import datetime, timedelta
import readchar
import yfinance as yf
import csv
import os

class StockPrediction:
    def __init__(self):
        self.predictions = []
        self.filename = "stock_predictions.csv"
        self.load_predictions()
        self.stock_tickers = [
            # Tech Giants
            "AAPL", "MSFT", "AMZN", "GOOGL", "FB", "TSLA", "NVDA", "ADBE", "CRM", "INTC", 
            "CSCO", "ORCL", "IBM", "ACN", "AMD", "QCOM", "TXN", "AVGO", "MU", "AMAT",
            
            # Financial Services
            "BRK-B", "JPM", "V", "MA", "BAC", "WFC", "C", "AXP", "MS", "GS", 
            "SCHW", "SPGI", "BLK", "CME", "ICE", "CB", "PNC", "TRV", "AIG", "MET",
            
            # Healthcare
            "JNJ", "UNH", "PFE", "ABT", "ABBV", "MRK", "TMO", "LLY", "DHR", "BMY", 
            "AMGN", "MDT", "ISRG", "GILD", "VRTX", "BIIB", "REGN", "BSX", "ZBH", "ILMN",
            
            # Consumer Goods & Retail
            "WMT", "PG", "HD", "KO", "PEP", "COST", "NKE", "MCD", "SBUX", "TGT", 
            "LOW", "EL", "CL", "KMB", "GIS", "K", "HSY", "SYY", "CAG", "HRL",
            
            # Industrial & Energy
            "XOM", "CVX", "GE", "BA", "LMT", "RTX", "HON", "UNP", "UPS", "CAT", 
            "DE", "MMM", "EMR", "ETN", "ITW", "NSC", "WM", "RSG", "ROK", "CMI",
            
            # Telecommunications & Media
            "VZ", "T", "CMCSA", "NFLX", "DIS", "CHTR", "TMUS", "ATVI", "EA", "TTWO",
            
            # Others
            "PYPL", "SQ", "COP", "PM", "AMT", "BDX", "APD", "ECL", "SHW", "LIN"
        ]
        self.used_tickers = set()

        
    def get_user_input(self, prompt, valid_inputs):
        while True:
            user_input = input(prompt).lower()
            if user_input in valid_inputs:
                return user_input
            print("Invalid input. Please try again.")

    def get_float_input(self, prompt, min_val, max_val):
        while True:
            try:
                user_input = float(input(prompt))
                if min_val <= user_input <= max_val:
                    return user_input
                print(f"Please enter a number between {min_val} and {max_val}.")
            except ValueError:
                print("Invalid input. Please enter a number.")

    def get_random_ticker(self):
        available_tickers = list(set(self.stock_tickers) - self.used_tickers)
        if not available_tickers:
            print("All tickers have been used. Resetting the list.")
            self.used_tickers.clear()
            available_tickers = self.stock_tickers
        
        ticker = random.choice(available_tickers)
        self.used_tickers.add(ticker)
        return ticker

    def get_stock_data(self, ticker):
        try:
            stock = yf.Ticker(ticker)
            current_price = stock.info['currentPrice']
            return current_price
        except:
            print(f"Error fetching data for {ticker}. Using placeholder data.")
            return 100.00  # Placeholder price

    def get_user_predictions(self):
        while True:
            try:
                num_stocks = int(input("How many stocks would you like to make predictions on? "))
                if num_stocks > 0:
                    break
                print("Please enter a positive number.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        print("\nSelect a time frame for your predictions:")
        print("1. 1 month")
        print("2. 3 months")
        print("3. 1 year")
        
        timeframe_choice = self.get_user_input("Enter your choice (1, 2, or 3): ", ['1', '2', '3'])
        
        timeframe_map = {'1': 1, '2': 3, '3': 12}
        timeframe = timeframe_map[timeframe_choice]
        timeframe_str = f"{timeframe} month{'s' if timeframe > 1 else ''}"
        
        print(f"\nMaking predictions for {num_stocks} stocks over {timeframe_str}.")
        
        for _ in range(num_stocks):
            self.get_single_prediction(timeframe, timeframe_str)
        
        self.save_predictions()

    def get_single_prediction(self, timeframe, timeframe_str):
        stock = self.get_random_ticker()
        price = self.get_stock_data(stock)
        
        print(f"\nSelected stock: {stock}")
        print(f"Current Price: ${price:.2f}")
        
        movement = random.choice(["rise", "fall"])
        print(f"The stock will {movement} in the next {timeframe_str}.")
        
        user_prediction = self.get_user_input("Enter 'true' if you agree, 'false' if you disagree: ", ['true', 'false'])
        
        confidence = self.get_float_input("Enter your confidence level (0-1): ", 0, 1)
        
        prediction = {
            'stock': stock,
            'price': price,
            'movement': movement,
            'timeframe': timeframe,
            'user_prediction': user_prediction == 'true',
            'confidence': confidence,
            'timestamp': datetime.now(),
            'evaluation_date': datetime.now() + timedelta(days=30*timeframe)
        }
    
        self.predictions.append(prediction)
        print("Prediction recorded!")

    def get_stock_data(self, ticker):
        try:
            stock = yf.Ticker(ticker)
            current_price = stock.info['currentPrice']
            return current_price
        except:
            print(f"Error fetching data for {ticker}. Using placeholder data.")
            return 100.00  # Placeholder price


    def get_single_prediction(self, timeframe, timeframe_str):
        stock = self.get_random_ticker()
        price = self.get_stock_data(stock)
        
        print(f"\nStock: {stock}")
        print(f"Current Price: ${price:.2f}")
        
        movement = random.choice(["rise", "fall"])
        print(f"The stock will {movement} in the next {timeframe_str}.")
        
        user_prediction = self.get_user_input("Enter 'true' if you agree, 'false' if you disagree: ", ['true', 'false'])
        
        confidence = self.get_float_input("Enter your confidence level (0-1): ", 0, 1)
        
        prediction = {
            'stock': stock,
            'price': price,
            'movement': movement,
            'timeframe': timeframe,
            'user_prediction': user_prediction == 'true',
            'confidence': confidence,
            'timestamp': datetime.now(),
            'evaluation_date': datetime.now() + timedelta(days=30*timeframe)
        }
        
        self.predictions.append(prediction)
        print("Prediction recorded!")

    def display_predictions(self):
        if not self.predictions:
            print("No predictions recorded yet.")
            return
        
        print("\nYour Predictions:")
        for idx, pred in enumerate(self.predictions, 1):
            timeframe_str = f"{pred['timeframe']} month{'s' if pred['timeframe'] > 1 else ''}"
            print(f"\n{idx}. Stock: {pred['stock']}")
            print(f"   Current Price: ${pred['price']:.2f}")
            print(f"   Predicted {'rise' if pred['user_prediction'] else 'fall'} in {timeframe_str}")
            print(f"   with {pred['confidence']:.2f} confidence")
            print(f"   Made on: {pred['timestamp'].strftime('%Y-%m-%d %H:%M:%S')}")
            print(f"   To be evaluated on: {pred['evaluation_date'].strftime('%Y-%m-%d')}")

    def save_predictions(self):
        with open(self.filename, 'w', newline='') as csvfile:
            fieldnames = ['stock', 'price', 'movement', 'timeframe', 'user_prediction', 'confidence', 'timestamp', 'evaluation_date']
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            
            writer.writeheader()
            for pred in self.predictions:
                writer.writerow(pred)
        
        print(f"Predictions saved to {self.filename}")

    def load_predictions(self):
        if not os.path.exists(self.filename):
            return
        
        with open(self.filename, 'r') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                row['price'] = float(row['price'])
                row['timeframe'] = int(row['timeframe'])
                row['user_prediction'] = row['user_prediction'] == 'True'
                row['confidence'] = float(row['confidence'])
                row['timestamp'] = datetime.fromisoformat(row['timestamp'])
                row['evaluation_date'] = datetime.fromisoformat(row['evaluation_date'])
                self.predictions.append(row)
        
        print(f"Loaded {len(self.predictions)} predictions from {self.filename}")

def main():
    predictor = StockPrediction()
    
    while True:
        print("\n1. Make predictions")
        print("2. View predictions")
        print("3. Exit")
        print("Press the number key for your choice...")
        
        choice = readchar.readkey()
        
        if choice == '1':
            predictor.get_user_predictions()
        elif choice == '2':
            predictor.display_predictions()
        elif choice == '3':
            print("\nThank you for using the Stock Prediction App!")
            break
        else:
            print("Invalid choice. Please try again.")

if __name__ == "__main__":
    main()
